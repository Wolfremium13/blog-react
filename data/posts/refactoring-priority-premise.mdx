---
title: "üåπ Premisa de prioridad de refactorizaci√≥n"
date: "2023-10-21"
preview: "/assets/blog/refactoring-priority-premise/weird-cat.webp"
tags:
  - "‚ú® Edici√≥n Especial"
---

En ocasiones, me asalta la idea de que deber√≠a adoptar una estrategia proactiva
al enfrentar la refactorizaci√≥n de c√≥digo legacy. Para m√≠, el t√©rmino "c√≥digo
legacy" abarca todo c√≥digo que, desde mi perspectiva, podr√≠a ser optimizado. Son
contadas las veces que me he topado con c√≥digo que no requer√≠a ninguna
modificaci√≥n o mejora, gracias a una adecuada nominaci√≥n o estructuraci√≥n.

## üí® TL;DR

Este a√±o 2023, en Pamplona Software Crafters, tuve la oportunidad de conocer a
Pedro Santos y su charla ‚ÄúRefactoring Priority Premise‚Äù, que aborda c√≥mo
identificar y remediar code smells siguiendo un orden espec√≠fico. Dicho orden se
determinaba en funci√≥n del problema que necesitabas resolver; por ejemplo, la
legibilidad ocupaba el primer nivel y pod√≠a ser mejorada mediante cambios de
nombre, comentarios, entre otros. La intenci√≥n de este art√≠culo, que ser√° el
precursor de una serie, es elucidar, mediante ejemplos, por qu√© no solo es
crucial realizar una refactorizaci√≥n, sino c√≥mo llevarla a cabo.No
profundizaremos en c√≥mo se realiza la refactorizaci√≥n ni en el tiempo que se le
debe dedicar; en cambio, nos enfocaremos en el orden de refactorizaci√≥n.

> ‚ö† Aviso de antemano que sera un art√≠culo largo, y soy consciente de t√©cnicas
> que se pueden aplicar para hacerlo mas corto, pero la idea es que se pueda ser
> le√≠do por cualquier persona sin conocimientos previos de refactorizaci√≥n.

## üìù Contexto

Trabajaremos con el c√≥digo de Gilded Rose, un proyecto que se ha utilizado en
numerosas conferencias y talleres de refactorizaci√≥n. El c√≥digo original fue
escrito en C#, pero en esta ocasi√≥n, trabajaremos con una versi√≥n en Kotlin
traducida por
[Emily Bache](https://github.com/emilybache/GildedRose-Refactoring-Kata/tree/main/Kotlin).

A menudo me gusta reflexionar sobre la refactorizaci√≥n tal como me la ense√±√≥
Carlos Bl√©. Imaginemos un cubo de Rubik, en el cual debemos ejecutar una serie
de pasos para alcanzar la soluci√≥n. Estos pasos pueden variar dado que existen
m√∫ltiples posibilidades, pero el objetivo permanece inalterable. Quiero decir
con esto que la refactorizaci√≥n se rige por numerosas heur√≠sticas, y ejecutarla
adecuadamente depender√° de tu experiencia previa o de la herramienta que est√©s
utilizando, como por ejemplo, IntelliJ.

Para ilustrar esto, trabajaremos con ejemplos detallados, convirtiendo el
proceso en una experiencia m√°s artesanal, para que no solo comprendamos el
nombre del refactor, sino c√≥mo se implementa y d√≥nde. En este caso, voy a
elaborar todas las pruebas (tests) de antemano, ya que sin ellas, resulta muy
dif√≠cil llevar a cabo una refactorizaci√≥n.

En esta ocasi√≥n, trabajar√© con Kotlin, un lenguaje de programaci√≥n que siempre
ha capturado mi inter√©s, utilizando la versi√≥n Community de IntelliJ IDEA, al
igual que muchos otros desarrolladores. Comenzaremos revisando brevemente el
c√≥digo.

`GildedRose.kt`

```kotlin
package dev.wolfremium.www

class GildedRose(var items: List<Item>) {
    fun updateQuality() {
        for (i in items.indices) {
            if (items[i].name != "Aged Brie" && items[i].name != "Backstage passes to a TAFKAL80ETC concert") {
                if (items[i].quality > 0) {
                    if (items[i].name != "Sulfuras, Hand of Ragnaros") {
                        items[i].quality = items[i].quality - 1
                    }
                }
            } else {
                if (items[i].quality < 50) {
                    items[i].quality = items[i].quality + 1

                    if (items[i].name == "Backstage passes to a TAFKAL80ETC concert") {
                        if (items[i].sellIn < 11) {
                            if (items[i].quality < 50) {
                                items[i].quality = items[i].quality + 1
                            }
                        }

                        if (items[i].sellIn < 6) {
                            if (items[i].quality < 50) {
                                items[i].quality = items[i].quality + 1
                            }
                        }
                    }
                }
            }

            if (items[i].name != "Sulfuras, Hand of Ragnaros") {
                items[i].sellIn = items[i].sellIn - 1
            }

            if (items[i].sellIn < 0) {
                if (items[i].name != "Aged Brie") {
                    if (items[i].name != "Backstage passes to a TAFKAL80ETC concert") {
                        if (items[i].quality > 0) {
                            if (items[i].name != "Sulfuras, Hand of Ragnaros") {
                                items[i].quality = items[i].quality - 1
                            }
                        }
                    } else {
                        items[i].quality = items[i].quality - items[i].quality
                    }
                } else {
                    if (items[i].quality < 50) {
                        items[i].quality = items[i].quality + 1
                    }
                }
            }
        }
    }
}
```

`Item.kt`

```kotlin
package dev.wolfremium.www

open class Item(var name: String, var sellIn: Int, var quality: Int) {
    override fun toString(): String {
        return this.name + ", " + this.sellIn + ", " + this.quality
    }
}
```

Como podr√°n observar, les invito a examinar nuevamente el c√≥digo anterior con
detenimiento, y destacar los aspectos que les llamen la atenci√≥n. En mi caso, he
identificado los siguientes puntos:

- Complejidad Anidada
- C√≥digo Duplicado
- Literales M√°gicos
- Violaci√≥n del Principio de Responsabilidad √önica (SRP)
- Falta de Encapsulaci√≥n
- Problemas de Extensibilidad y Mantenibilidad
- Uso Ineficiente de los √çndices
- Obsesi√≥n por los primitivos

Ahora, para maximizar nuestro retorno de inversi√≥n, la clave ser√° clasificar
estos puntos desde el m√°s f√°cil hasta el m√°s dif√≠cil de corregir. Seg√∫n mi
an√°lisis, he establecido el siguiente orden:

1. Literales M√°gicos
2. Uso Ineficiente de los √çndices
3. Complejidad Anidada y C√≥digo Duplicado
4. Violaci√≥n del Principio de Responsabilidad √önica (SRP)
5. Falta de Encapsulaci√≥n
6. Problemas de Extensibilidad y Mantenibilidad

Procederemos a rectificar cada aspecto, explicando d√≥nde se manifiesta en el
c√≥digo y c√≥mo corregirlo.

## üßô‚Äç‚ôÇÔ∏è Literales M√°gicos

Los literales m√°gicos son valores que se encuentran en el c√≥digo sin una
explicaci√≥n o contexto claro. En este caso, es evidente que el valor 50 se
repite en m√∫ltiples ocasiones, pero no se entiende su significado. Al analizar
el c√≥digo, identificamos que `items[i].quality < 50` es una expresi√≥n
recurrente, y adem√°s, el valor 50 representa el l√≠mite superior. Por lo tanto,
es prudente crear una constante llamada `maxQuality` y asignarle el valor 50.
Para lograr esto, utilizaremos el atajo `Ctrl + Alt + V` en IntelliJ sobre uno
de los valores 50 para extraer la variable.

`GildedRose.kt`

```kotlin
for (i in items.indices) {
    val maxQuality = 50
    if (items[i].name != "Aged Brie" && items[i].name != "Backstage passes to a TAFKAL80ETC concert") {
        if (items[i].quality > 0) {
            if (items[i].name != "Sulfuras, Hand of Ragnaros") {
                items[i].quality = items[i].quality - 1
            }
        }
    } else {
        if (items[i].quality < maxQuality) {
            items[i].quality = items[i].quality + 1

            if (items[i].name == "Backstage passes to a TAFKAL80ETC concert") {
                if (items[i].sellIn < 11) {
                    if (items[i].quality < maxQuality) {
                        items[i].quality = items[i].quality + 1
                    }
                }

                if (items[i].sellIn < 6) {
                    if (items[i].quality < maxQuality) {
                        items[i].quality = items[i].quality + 1
                    }
                }
            }
        }
    }
// ...
```

> üí° Nota: Siempre que sea posible, es recomendable lanzar los tests para
> verificar que no hemos introducido ning√∫n error.

Es un peque√±o cambio, pero ya podemos observar una mejora en la legibilidad del
c√≥digo. Vamos a hacer los mismo con:

- `0` ‚Üí `minQuality`
- `11` ‚Üí `backstagePassesBigThreshold`
- `6` ‚Üí `backstagePassesSmallThreshold`
- `"Aged Brie"` ‚Üí `agedBrie`
- `"Backstage passes to a TAFKAL80ETC concert"` ‚Üí `backstagePasses`
- `"Sulfuras, Hand of Ragnaros"` ‚Üí `sulfuras`
- `1` ‚Üí `qualityIncrement`
- `-1` ‚Üí `qualityDecrement`

`GildedRose.kt`

```kotlin
class GildedRose(var items: List<Item>) {
    fun updateQuality() {
        for (i in items.indices) {
            val maxQuality = 50
            val minQuality = 0
            val agedBrie = "Aged Brie"
            val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
            val sulfuras = "Sulfuras, Hand of Ragnaros"
            val qualityIncrease = 1
            val qualityDecrease = 1
            if (items[i].name != agedBrie && items[i].name != backstagePasses) {
                if (items[i].quality > minQuality) {
                    if (items[i].name != sulfuras) {
                        items[i].quality = items[i].quality - qualityDecrease
                    }
                }
            } else {
                if (items[i].quality < maxQuality) {
                    items[i].quality = items[i].quality + qualityIncrease

                    if (items[i].name == backstagePasses) {
                        val backstagePassesBigThreshold = 11
                        if (items[i].sellIn < backstagePassesBigThreshold) {
                            if (items[i].quality < maxQuality) {
                                items[i].quality = items[i].quality + qualityIncrease
                            }
                        }

                        val backstagePassesSmallThreshold = 6
                        if (items[i].sellIn < backstagePassesSmallThreshold) {
                            if (items[i].quality < maxQuality) {
                                items[i].quality = items[i].quality + qualityIncrease
                            }
                        }
                    }
                }
            }

            if (items[i].name != sulfuras) {
                items[i].sellIn = items[i].sellIn - 1
            }

            if (items[i].sellIn < minQuality) {
                if (items[i].name != agedBrie) {
                    if (items[i].name != backstagePasses) {
                        if (items[i].quality > minQuality) {
                            if (items[i].name != sulfuras) {
                                items[i].quality = items[i].quality - qualityDecrease
                            }
                        }
                    } else {
                        items[i].quality = items[i].quality - items[i].quality
                    }
                } else {
                    if (items[i].quality < maxQuality) {
                        items[i].quality = items[i].quality + qualityIncrease
                    }
                }
            }
        }
    }
}
```

Perfecto üëå. Ahora, podemos observar que el c√≥digo es m√°s legible, pero a√∫n nos
queda un largo camino por recorrer. En este punto, es importante mencionar que
no debemos preocuparnos por la eficiencia del c√≥digo, ya que la refactorizaci√≥n
se centra en la legibilidad y la mantenibilidad. Siempre podemos optimizar el
c√≥digo m√°s adelante, pero primero debemos asegurarnos de que sea f√°cil de
entender.

## ü§î Uso Ineficiente de los √çndices

El uso ineficiente de los √≠ndices es un problema com√∫n en el desarrollo de
software, y generalmente se debe a la falta de abstracci√≥n. En este caso,
podemos observar que el √≠ndice `i` se repite en m√∫ltiples ocasiones, y que
realmente no necesitamos ese numero para mas nada que para acceder a a posici√≥n
de la lista `items`. Hay veces que IntelliJ no nos ayuda a convertir los bucles
a un `forEach`, por lo que tendremos que realizar un paso intermedio.

Empezaremos con extraer el c√≥digo `items[i]` a una variable llamada `item` y
utilizarla en su lugar. Para lograr esto, utilizaremos el atajo `Ctrl + Alt + V`
en IntelliJ sobre `items[i]` para extraer la variable.

`GildedRose.kt`

```kotlin
fun updateQuality() {
    for (i in items.indices) {
        val maxQuality = 50
        val minQuality = 0
        val agedBrie = "Aged Brie"
        val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
        val sulfuras = "Sulfuras, Hand of Ragnaros"
        val qualityIncrease = 1
        val qualityDecrease = 1
        val item = items[i]
        if (item.name != agedBrie && item.name != backstagePasses) {
            if (item.quality > minQuality) {
                if (item.name != sulfuras) {
                    item.quality = item.quality - qualityDecrease
                }
            }
// ...
```

Cambiamos el bucle `for` por con lo siguiente manualmente:

```kotlin
for (item in items) {
// ...
```

Vemos que la variable item que se extrajo anteriormente ya esta asignada por el
bucle por lo que deberemos borrarla. Ahora si podemos convertir el bucle a un
`forEach` utilizando el atajo `Alt + Enter` en IntelliJ.

`GildedRose.kt`

```kotlin
fun updateQuality() {
    items.forEach { item ->
        val maxQuality = 50
        val minQuality = 0
        val agedBrie = "Aged Brie"
        val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
        val sulfuras = "Sulfuras, Hand of Ragnaros"
        val qualityIncrease = 1
        val qualityDecrease = 1
        if (item.name != agedBrie && item.name != backstagePasses) {
            if (item.quality > minQuality) {
                if (item.name != sulfuras) {
                    item.quality = item.quality - qualityDecrease
                }
            }
// ...
```

üëå Maravilloso.

## ü§Ø Complejidad Anidada y C√≥digo Duplicado

La complejidad anidada es un problema que se manifiesta cuando tenemos m√∫ltiples
condiciones anidadas, y que generalmente se debe a la falta de abstracci√≥n. En
este caso, podemos observar que el c√≥digo se vuelve dif√≠cil de leer debido a la
cantidad de condiciones anidadas. Para remediar esto, utilizaremos el atajo
`Alt + Enter` en IntelliJ sobre el `if` para invertir la primera condici√≥n.

`GildedRose.kt`

```kotlin
fun updateQuality() {
    items.forEach { item ->
        val maxQuality = 50
        val minQuality = 0
        val agedBrie = "Aged Brie"
        val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
        val sulfuras = "Sulfuras, Hand of Ragnaros"
        val qualityIncrease = 1
        val qualityDecrease = 1
        if (item.name == agedBrie || item.name == backstagePasses) {
            if (item.quality < maxQuality) {
                item.quality = item.quality + qualityIncrease

                if (item.name == backstagePasses) {
                    val backstagePassesBigThreshold = 11
                    if (item.sellIn < backstagePassesBigThreshold) {
                        if (item.quality < maxQuality) {
                            item.quality = item.quality + qualityIncrease
                        }
                    }

                    val backstagePassesSmallThreshold = 6
                    if (item.sellIn < backstagePassesSmallThreshold) {
                        if (item.quality < maxQuality) {
                            item.quality = item.quality + qualityIncrease
                        }
                    }
                }
            }
        } else {
            if (item.quality > minQuality) {
                if (item.name != sulfuras) {
                    item.quality = item.quality - qualityDecrease
                }
            }
        }
// ...
```

Ahora, vemos que es mas f√°cil de leer una condici√≥n sin negarla pero tenemos que
aplicar el mismo cambio a las otras condiciones. Para lograr esto, utilizaremos
la misma t√©cnica para aquellos casos que tienen un `else`. Esto solo ha
solucionado un poco el problema de la legibilidad.

La idea es empezar a generar las condiciones id√≥neas para mover las condiciones
lo mas a la izquierda posible. Otro tipo de refactor es mergear las condiciones
de los `if` vamos a hacerlo con este caso:

`GildedRose.kt`

```kotlin
if (item.quality > minQuality) {
    if (item.name != sulfuras) {
        item.quality = item.quality - qualityDecrease
    }
}
```

Lo convertimos usando el atajo `Alt + Enter` sobre el primer `if` y
seleccionamos la opci√≥n `Merge if's`:

`GildedRose.kt`

```kotlin
if (item.quality > minQuality && item.name != sulfuras) {
    item.quality = item.quality - qualityDecrease
}
```

> üí° Nota: Esto solo aplica cuando tienes varios `if` seguidos y no tienen un
> `else` en medio.

Con esta t√©cnica podemos reducir la complejidad anidada ya que evitamos un
bloque mas de identaci√≥n. Vamos a hacer lo mismo con otros bloques de c√≥digo y
veamos el resultado:

`GildedRose.kt`

```kotlin
class GildedRose(var items: List<Item>) {
    fun updateQuality() {
        items.forEach { item ->
            val maxQuality = 50
            val minQuality = 0
            val agedBrie = "Aged Brie"
            val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
            val sulfuras = "Sulfuras, Hand of Ragnaros"
            val qualityIncrease = 1
            val qualityDecrease = 1
            if (item.name == agedBrie || item.name == backstagePasses) {
                if (item.quality < maxQuality) {
                    item.quality = item.quality + qualityIncrease
                    if (item.name == backstagePasses) {
                        val backstagePassesBigThreshold = 11
                        if (item.sellIn < backstagePassesBigThreshold && item.quality < maxQuality) {
                            item.quality = item.quality + qualityIncrease
                        }

                        val backstagePassesSmallThreshold = 6
                        if (item.sellIn < backstagePassesSmallThreshold && item.quality < maxQuality) {
                            item.quality = item.quality + qualityIncrease
                        }
                    }
                }
            } else {
                if (item.quality > minQuality && item.name != sulfuras) {
                    item.quality = item.quality - qualityDecrease
                }
            }

            if (item.name != sulfuras) {
                item.sellIn = item.sellIn - 1
            }

            if (item.sellIn < minQuality) {
                if (item.name == agedBrie) {
                    if (item.quality < maxQuality) {
                        item.quality = item.quality + qualityIncrease
                    }
                } else {
                    if (item.name == backstagePasses) {
                        item.quality = item.quality - item.quality
                    } else {
                        if (item.quality > minQuality && item.name != sulfuras) {
                            item.quality = item.quality - qualityDecrease
                        }
                    }
                }
            }
        }
    }
}
```

Ha mejorado un poco pero a√∫n tenemos complejidad anidada. Veo que las
condiciones se han complicado un poco, vamos a ver si podemos simplificarlas.
Vamos a empezar por este bloque de c√≥digo:

`GildedRose.kt`

```kotlin
if (item.quality < maxQuality) {
    item.quality = item.quality + qualityIncrease
    if (item.name == backstagePasses) {
        val backstagePassesBigThreshold = 11
        if (item.sellIn < backstagePassesBigThreshold && item.quality < maxQuality) {
            item.quality = item.quality + qualityIncrease
        }

        val backstagePassesSmallThreshold = 6
        if (item.sellIn < backstagePassesSmallThreshold && item.quality < maxQuality) {
            item.quality = item.quality + qualityIncrease
        }
    }
}
```

Vamos a extraer el c√≥digo `item.quality < maxQuality` a una variable llamada
`isNotTheMaximumQuality` y utilizarla en su lugar. Para lograr esto,
utilizaremos el atajo `Ctrl + Alt + V` en IntelliJ sobre
`item.quality < maxQuality` para extraer la variable.

`GildedRose.kt`

```kotlin
val isNotTheMaximumQuality = item.quality < maxQuality
if (item.name == agedBrie || item.name == backstagePasses) {
    if (isNotTheMaximumQuality) {
        item.quality = item.quality + qualityIncrease
        if (item.name == backstagePasses) {
            val backstagePassesBigThreshold = 11
            if (!(item.sellIn >= backstagePassesBigThreshold) && isNotTheMaximumQuality) {
                item.quality = item.quality + qualityIncrease
            }

            val backstagePassesSmallThreshold = 6
            if (item.sellIn < backstagePassesSmallThreshold && isNotTheMaximumQuality) {
                item.quality = item.quality + qualityIncrease
            }
        }
    }
// ...
```

Vamos a hacer lo mismo con el resto de condiciones y veamos el resultado:

`GildedRose.kt`

```kotlin
class GildedRose(var items: List<Item>) {
    fun updateQuality() {
        items.forEach { item ->
            val maxQuality = 50
            val minQuality = 0
            val agedBrie = "Aged Brie"
            val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
            val sulfuras = "Sulfuras, Hand of Ragnaros"
            val qualityIncrease = 1
            val qualityDecrease = 1
            val isNotTheMaximumQuality = item.quality < maxQuality
            val isAgedBrie = item.name == agedBrie
            val isABackStagePass = item.name == backstagePasses
            val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
            val hasQuality = item.quality > minQuality
            val isNotSulfuras = item.name != sulfuras
            if (areAgeBrieOrPasses) {
                if (isNotTheMaximumQuality) {
                    item.quality = item.quality + qualityIncrease
                    if (isABackStagePass) {
                        val backstagePassesBigThreshold = 11
                        val areInDateToBeSold = item.sellIn < backstagePassesBigThreshold
                        if (areInDateToBeSold && isNotTheMaximumQuality) {
                            item.quality = item.quality + qualityIncrease
                        }

                        val backstagePassesSmallThreshold = 6
                        val areOnTheLastDays = item.sellIn < backstagePassesSmallThreshold
                        if (areOnTheLastDays && isNotTheMaximumQuality) {
                            item.quality = item.quality + qualityIncrease
                        }
                    }
                }
            } else {
                if (hasQuality && isNotSulfuras) {
                    item.quality = item.quality - qualityDecrease
                }
            }

            if (isNotSulfuras) {
                item.sellIn = item.sellIn - 1
            }

            val notExpiredNumber = 0
            val isExpired = item.sellIn < notExpiredNumber
            if (isExpired) {
                if (isAgedBrie) {
                    if (isNotTheMaximumQuality) {
                        item.quality = item.quality + qualityIncrease
                    }
                } else {
                    if (isABackStagePass) {
                        item.quality = item.quality - item.quality
                    } else {
                        if (hasQuality && isNotSulfuras) {
                            item.quality = item.quality - qualityDecrease
                        }
                    }
                }
            }
        }
    }
}
```

Ahora, podemos observar que las variables le dan legibilidad al c√≥digo, pero a√∫n
tenemos complejidad anidada para desgracia de nosotros. Esta vez vamos a
reordenar y extraer en m√©todos las condiciones para que sea mas f√°cil de leer.
Vamos a empezar por este bloque de c√≥digo:

`GildedRose.kt`

```kotlin
if (isNotSulfuras) {
    item.sellIn = item.sellIn - 1
}
```

Podemos antes de empezar realizar una peque√±a refactorizaci√≥n para que sea mas
f√°cil de leer:

`GildedRose.kt`

```kotlin
if (isNotSulfuras) {
    val dayDecrease = 1
    item.sellIn -= dayDecrease
}
```

Os preguntareis porque no lo hice antes, la respuesta es que no era tan f√°cil de
leer el c√≥digo por lo que aunque estemos resolviendo un problema de complejidad
hace falta poner foco en lo sencillo y asequible. Volviendo a resolver
legibilidad antes que complejidad siguiendo el orden de lo que es mas f√°cil de
resolver.

Ahora si podemos extraer el c√≥digo a un m√©todo llamado `decreaseSellIn` y
utilizarlo en su lugar. Para lograr esto, utilizaremos el atajo `Ctrl + Alt + M`
en IntelliJ sobre para extraer el m√©todo.

`GildedRose.kt`

```kotlin
private fun decreaseSellIn(isNotSulfuras: Boolean, item: Item) {
    if (isNotSulfuras) {
        val dayDecrease = 1
        item.sellIn -= dayDecrease
    }
}
```

Sin darnos cuenta ya hemos encapsulado en un m√©todo la complejidad anidada de
reducir `SellIn`. Vemos que el m√©todo anterior tiene un par√°metro que no es
utilizado en el m√©todo, esto es un indicador de que el m√©todo no esta bien
encapsulado. Vamos a extraer el c√≥digo `isNotSulfuras` a un m√©todo llamado
`isNotSulfuras` y utilizarlo en su lugar. Para lograr esto, utilizaremos el
atajo `Ctrl + Alt + M` en IntelliJ sobre para extraer el m√©todo.

`GildedRose.kt`

```kotlin
private fun isNotSulfuras(item: Item): Boolean {
    val sulfuras = "Sulfuras, Hand of Ragnaros"
    return item.name != sulfuras
}
```

Se va a quedar la variable `val isNotSulfuras = isNotSulfuras(item)` que
representa lo mismo que el m√©todo pero no es necesario ya que el m√©todo es mas
legible. Vamos a eliminar la variable y utilizar el m√©todo en su lugar, usando
el atajo `Ctrl + Alt + N` o `Inline property` sobre la variable.

`GildedRose.kt`

```kotlin
//...
else {
    if (hasQuality && isNotSulfuras(item)) {
        item.quality = item.quality - qualityDecrease
    }
}

decreaseSellIn(isNotSulfuras(item), item)
//...
```

Queda feo el m√©todo `decreaseSellIn` con el par√°metro `isNotSulfuras(item)` por
lo que vamos a quitar el par√°metro y utilizar el m√©todo `isNotSulfuras` dentro
del m√©todo `decreaseSellIn`.

`GildedRose.kt`

```kotlin
private fun decreaseSellIn(isNotSulfuras: Boolean, item: Item) {
    if (isNotSulfuras(item)) {
        val dayDecrease = 1
        item.sellIn -= dayDecrease
    }
}
```

Seguidamente borramos el par√°metro `isNotSulfuras` que no esta siendo utilizado
con `Alt + Enter` y seleccionamos la opci√≥n `Remove parameter 'isNotSulfuras'`:

`GildedRose.kt`

```kotlin
private fun decreaseSellIn(item: Item) {
    if (isNotSulfuras(item)) {
        val dayDecrease = 1
        item.sellIn -= dayDecrease
    }
}
```

Ahora que hemos separado toda la l√≥gica del `SellIn` nos quedar√≠a la mejora de
la calidad y el empeoramiento de la misma. Vamos a mirar detenidamente este
caso:

`GildedRose.kt`

```kotlin
//...
if (areAgeBrieOrPasses) {
    if (isNotTheMaximumQuality) {
        item.quality += qualityIncrease
        if (isABackStagePass) {
            val backstagePassesBigThreshold = 11
            val areInDateToBeSold = item.sellIn < backstagePassesBigThreshold
            if (areInDateToBeSold && isNotTheMaximumQuality) {
                item.quality = item.quality + qualityIncrease
            }

            val backstagePassesSmallThreshold = 6
            val areOnTheLastDays = item.sellIn < backstagePassesSmallThreshold
            if (areOnTheLastDays && isNotTheMaximumQuality) {
                item.quality = item.quality + qualityIncrease
            }
        }
    }
} else {
    if (hasQuality && isNotSulfuras(item)) {
        item.quality = item.quality - qualityDecrease
    }
}
decreaseSellIn(item)

val notExpiredNumber = 0
    val isExpired = item.sellIn < notExpiredNumber
    if (isExpired) {
        if (isAgedBrie) {
            if (isNotTheMaximumQuality) {
                item.quality = item.quality + qualityIncrease
            }
        } else {
            if (isABackStagePass) {
                item.quality = item.quality - item.quality
            } else {
                if (hasQuality && isNotSulfuras(item)) {
                    item.quality = item.quality - qualityDecrease
                }
            }
        }
    }
}
//...
```

Vemos que se ha mezclado totalmente la l√≥gica de la calidad y el empeoramiento.
Vamos a separarlos agregando las condiciones y moveremos el c√≥digo a la
izquierda para que sea mas f√°cil luego extraer un m√©todo. En el bloque de arriba
todo aumenta menos el primer `else`.

`GildedRose.kt`

```kotlin
else {
    if (hasQuality && isNotSulfuras(item)) {
        item.quality = item.quality - qualityDecrease
    }
}
```

Para convertirlo en un if simple vamos a a√±adir la negaci√≥n del if mas sus
condiciones:

`GildedRose.kt`

```kotlin
if (!areAgeBrieOrPasses && hasQuality && isNotSulfuras(item)) {
    item.quality -= qualityDecrease
}
```

Bien ahora vamos a hacer lo mismo con el bloque de abajo:

`GildedRose.kt`

```kotlin
//...
val notExpiredNumber = 0
val isExpired = item.sellIn < notExpiredNumber
if (isExpired) {
    if (isAgedBrie) {
        if (isNotTheMaximumQuality) {
            item.quality = item.quality + qualityIncrease
        }
    } else {
        if (isABackStagePass) {
            item.quality = item.quality - item.quality
        } else {
            if (hasQuality && isNotSulfuras(item)) {
                item.quality = item.quality - qualityDecrease
            }
        }
    }
}
//...
```

Aqu√≠, la linea que nos molesta es
`item.quality = item.quality + qualityIncrease` porque todo lo dem√°s resta
calidad al producto. Hacemos lo mismo que antes, a√±adimos toda la ruta de
condiciones.

`GildedRose.kt`

```kotlin
if (isExpired && isAgedBrie && isNotTheMaximumQuality) {
    item.quality = item.quality + qualityIncrease
}
```

Ahora tenemos la libertad de mover todo aquello que incremente o decremente
junto para poder extraerlo a un m√©todo. He reordenado el c√≥digo para que sea mas
f√°cil de leer y extraer el m√©todo.

`GildedRose.kt`

```kotlin
fun updateQuality() {
    items.forEach { item ->
        // Increase quality part
        val maxQuality = 50
        val agedBrie = "Aged Brie"
        val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
        val qualityIncrease = 1
        val isNotTheMaximumQuality = item.quality < maxQuality
        val isAgedBrie = item.name == agedBrie
        val isABackStagePass = item.name == backstagePasses
        val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
        if (areAgeBrieOrPasses) {
            if (isNotTheMaximumQuality) {
                item.quality += qualityIncrease
                if (isABackStagePass) {
                    val backstagePassesBigThreshold = 11
                    val areInDateToBeSold = item.sellIn < backstagePassesBigThreshold
                    if (areInDateToBeSold && isNotTheMaximumQuality) {
                        item.quality += qualityIncrease
                    }

                    val backstagePassesSmallThreshold = 6
                    val areOnTheLastDays = item.sellIn < backstagePassesSmallThreshold
                    if (areOnTheLastDays && isNotTheMaximumQuality) {
                        item.quality += qualityIncrease
                    }
                }
            }
        }
        decreaseSellIn(item)
        val notExpiredNumber = 0
        val isExpired = item.sellIn < notExpiredNumber
        if(isExpired && isAgedBrie && isNotTheMaximumQuality){
            item.quality += qualityIncrease
        }

        // Decrease quality part
        val qualityDecrease = 1
        val minQuality = 0
        val hasQuality = item.quality > minQuality
        if (!areAgeBrieOrPasses && hasQuality && isNotSulfuras(item)) {
            item.quality -= qualityDecrease
        }
        if (isExpired) {
            if (!isAgedBrie) {
                if (isABackStagePass) {
                    item.quality -= item.quality
                } else {
                    if (hasQuality && isNotSulfuras(item)) {
                        item.quality -= qualityDecrease
                    }
                }
            }
        }
    }
}
```

Vamos a extraer el c√≥digo a un m√©todo llamado `increaseQuality` y
`decreaseQuality` utilizarlos en su lugar. Para lograr esto, utilizaremos el
atajo `Ctrl + Alt + M` en IntelliJ sobre para extraer el m√©todo.

`GildedRose.kt`

```kotlin
fun updateQuality() {
    items.forEach { item ->
        increaseQuality(item)
        decreaseQuality(item)
    }
}

private fun decreaseQuality(item: Item) {
    val agedBrie = "Aged Brie"
    val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
    val isAgedBrie = item.name == agedBrie
    val isABackStagePass = item.name == backstagePasses
    val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
    val notExpiredNumber = 0
    val isExpired = item.sellIn < notExpiredNumber
    val qualityDecrease = 1
    val minQuality = 0
    val hasQuality = item.quality > minQuality
    if (!areAgeBrieOrPasses && hasQuality && isNotSulfuras(item)) {
        item.quality -= qualityDecrease
    }
    if (isExpired) {
        if (!isAgedBrie) {
            if (isABackStagePass) {
                item.quality -= item.quality
            } else {
                if (hasQuality && isNotSulfuras(item)) {
                    item.quality -= qualityDecrease
                }
            }
        }
    }
}

private fun increaseQuality(item: Item) {
    val maxQuality = 50
    val agedBrie = "Aged Brie"
    val backstagePasses = "Backstage passes to a TAFKAL80ETC concert"
    val qualityIncrease = 1
    val isNotTheMaximumQuality = item.quality < maxQuality
    val isAgedBrie = item.name == agedBrie
    val isABackStagePass = item.name == backstagePasses
    val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
    if (areAgeBrieOrPasses) {
        if (isNotTheMaximumQuality) {
            item.quality += qualityIncrease
            if (isABackStagePass) {
                val backstagePassesBigThreshold = 11
                val areInDateToBeSold = item.sellIn < backstagePassesBigThreshold
                if (areInDateToBeSold && isNotTheMaximumQuality) {
                    item.quality += qualityIncrease
                }

                val backstagePassesSmallThreshold = 6
                val areOnTheLastDays = item.sellIn < backstagePassesSmallThreshold
                if (areOnTheLastDays && isNotTheMaximumQuality) {
                    item.quality += qualityIncrease
                }
            }
        }
    }
    decreaseSellIn(item)
    val notExpiredNumber = 0
    val isExpired = item.sellIn < notExpiredNumber
    if (isExpired && isAgedBrie && isNotTheMaximumQuality) {
        item.quality += qualityIncrease
    }
}
```

Si vemos detenidamente el m√©todo `updateQuality` parece que se ha simplificado
bastante el nivel de abstracci√≥n del m√©todo. Per los m√©todos aun tienen bastante
l√≥gica de condiciones compartida, recordemos que es mejor tener c√≥digo duplicado
que tener una mala abstracci√≥n. Como ya hemos visto antes con `isNotSulfuras`
vamos a extraer aquellas condiciones que se repiten en los m√©todos a un m√©todo.

`GildedRose.kt`

```kotlin
private fun decreaseQuality(item: Item) {
    val isAgedBrie = isAgedBrie(item)
    val isABackStagePass = isABackstagePass(item)
    val isExpired = isExpired(item)
    val qualityDecrease = 1
    val minQuality = 0
    val hasQuality = item.quality > minQuality
    val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
    if (!areAgeBrieOrPasses && hasQuality && isNotSulfuras(item)) {
        item.quality -= qualityDecrease
    }
    if (isExpired) {
        if (!isAgedBrie) {
            if (isABackStagePass) {
                item.quality -= item.quality
            } else {
                if (hasQuality && isNotSulfuras(item)) {
                    item.quality -= qualityDecrease
                }
            }
        }
    }
}

private fun increaseQuality(item: Item) {
    val maxQuality = 50
    val isNotTheMaximumQuality = item.quality < maxQuality
    val isAgedBrie = isAgedBrie(item)
    val isABackStagePass = isABackstagePass(item)
    val qualityIncrease = 1
    val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
    if (areAgeBrieOrPasses) {
        if (isNotTheMaximumQuality) {
            item.quality += qualityIncrease
            if (isABackStagePass) {
                val backstagePassesBigThreshold = 11
                val areInDateToBeSold = item.sellIn < backstagePassesBigThreshold
                if (areInDateToBeSold && isNotTheMaximumQuality) {
                    item.quality += qualityIncrease
                }

                val backstagePassesSmallThreshold = 6
                val areOnTheLastDays = item.sellIn < backstagePassesSmallThreshold
                if (areOnTheLastDays && isNotTheMaximumQuality) {
                    item.quality += qualityIncrease
                }
            }
        }
    }
    decreaseSellIn(item)
    val isExpired = isExpired(item)
    if (isExpired && isAgedBrie && isNotTheMaximumQuality) {
        item.quality += qualityIncrease
    }
}
```

Parece que va mejorando pero la realidad es que aun queda por delante bastante.
Ahora vamos a seguir atacando al m√©todo `decreaseQuality`, vamos a reducir la
complejidad anidada de este m√©todo. Hay una constante que se repite en el m√©todo
`hasQuality` por lo que vamos a crear una clausula guarda para que sea mas f√°cil
de leer.

`GildedRose.kt`

```kotlin
private fun decreaseQuality(item: Item) {
    val minQuality = 0
    val hasQuality = item.quality > minQuality
    if(!hasQuality) return
    val isAgedBrie = isAgedBrie(item)
    val isABackStagePass = isABackstagePass(item)
    val isExpired = isExpired(item)
    val qualityDecrease = 1
    val areAgeBrieOrPasses = isAgedBrie || isABackStagePass
    if (!areAgeBrieOrPasses && isNotSulfuras(item)) {
        item.quality -= qualityDecrease
    }
    if (isExpired) {
        if (!isAgedBrie) {
            if (isABackStagePass) {
                item.quality -= item.quality
            } else {
                if (isNotSulfuras(item)) {
                    item.quality -= qualityDecrease
                }
            }
        }
    }
}
```

Con este cambio podemos eliminar la variable `hasQuality` ya que no es necesario
volver a comprobarlo. vamos a hacer la misma t√©cnica con el resto de
condiciones.

`GildedRose.kt`

```kotlin
private fun decreaseQuality(item: Item) {
    val minQuality = 0
    val hasQuality = item.quality > minQuality
    if (!hasQuality) return
    val isExpired = isExpired(item)
    val qualityDecrease = 1
    if (isExpired && isABackstagePass(item)) {
        item.quality = minQuality
        return
    }
    val hasAnExpirationDate = !(isAgedBrie(item) || isABackstagePass(item)) && isNotSulfuras(item)
    if (isExpired && hasAnExpirationDate) {
        val expirationMultiplier = 2
        item.quality -= qualityDecrease * expirationMultiplier
        return
    }
    if (hasAnExpirationDate) {
        item.quality -= qualityDecrease
    }
}
```

Ahora podemos ver que el m√©todo `decreaseQuality` ha quedado bastante mas
limpio. He ordenado los m√©todos de mas concreto a mas abstracto para salir del
m√©todo lo antes posible, evitando errores. Vamos a hacer lo mismo con el m√©todo
`increaseQuality`.

`GildedRose.kt`

```kotlin
private fun increaseQuality(item: Item) {
    val maxQuality = 50
    val isNotTheMaximumQuality = item.quality < maxQuality
    val itHasTheMaximumQuality = item.quality == maxQuality
    if (itHasTheMaximumQuality) return
    val qualityIncrease = 1

    if (isABackstagePass(item)) {
        item.quality += qualityIncrease
        val backstagePassesBigThreshold = 11
        val areInDateToBeSold = item.sellIn < backstagePassesBigThreshold
        if (areInDateToBeSold && isNotTheMaximumQuality) {
            item.quality += qualityIncrease
        }
        val backstagePassesSmallThreshold = 6
        val areOnTheLastDays = item.sellIn < backstagePassesSmallThreshold
        if (areOnTheLastDays && isNotTheMaximumQuality) {
            item.quality += qualityIncrease
        }
        decreaseSellIn(item)
        return
    }

    if (isAgedBrie(item)) {
        item.quality += qualityIncrease
        decreaseSellIn(item)
        val isExpired = isExpired(item)
        if (isExpired && isNotTheMaximumQuality) {
            item.quality += qualityIncrease
        }
        return
    }
    decreaseSellIn(item)
}
```

Esta mejor pero el c√≥digo nos esta diciendo dos cosas, que arreglaremos mas
adelante, la primera es que el m√©todo `increaseQuality` tiene demasiadas
responsabilidades y la segunda es que el m√©todo `increaseQuality` tiene
demasiadas condiciones hacia items espec√≠ficos.

## üêç Violaci√≥n del Principio de Responsabilidad √önica (SRP)

El principio de responsabilidad √∫nica nos dice que cada clase debe tener una
√∫nica responsabilidad y que esta debe estar encapsulada en la clase. En este
caso, podemos observar que la clase `GildedRose` tiene varias responsabilidades
como son la actualizaci√≥n de la calidad y la actualizaci√≥n de la fecha de
caducidad. Resulta que antes de extraer nada tenemos que separar las reglas de
negocio:

- Para "Aged Brie", la calidad aumenta en 1 cada d√≠a, y si ha expirado, la
  calidad aumenta en 2.
- Para "Backstage passes", la calidad aumenta en 1 si faltan m√°s de 10 d√≠as para
  el concierto, en 2 si faltan 10 d√≠as o menos, y en 3 si faltan 5 d√≠as o menos.
  Sin embargo, la calidad cae a 0 despu√©s del concierto.
- Para los items regulares, la calidad disminuye en 1 cada d√≠a, y si ha
  expirado, la calidad disminuye en 2.
- Para "Sulfuras, Hand of Ragnaros", la calidad y sellIn permanecen sin cambios.
- La calidad de un item nunca es negativa y nunca es mayor que 50.

Para remediar esto, vamos a crear una clase abstracta llamada `ItemUpdater` que
se encargue de generar una interfaz para actualizar los items.

`ItemUpdater.kt`

```kotlin
abstract class ItemUpdater {
    protected val minQuality = 0
    protected val maxQuality = 50
    protected val qualityIncrease = 1
    protected val qualityDecrease = 1
    protected val dayDecrease = 1

    abstract fun updateQuality(item: Item)
    abstract fun decreaseSellIn(item: Item)

}
```

Ahora, vamos a crear una clase llamada `DefaultItemUpdater` que implemente la
interfaz `ItemUpdater` y que se encargue de actualizar los items.

`DefaultItemUpdater.kt`

```kotlin
class DefaultItemUpdater : ItemUpdater() {
    override fun updateQuality(item: Item) {
        if (hadQuality(item)) {
            decreaseQuality(item)
        }
        if (isExpired(item) && hadQuality(item)) {
            decreaseQuality(item)
        }
    }

    override fun decreaseSellIn(item: Item) {
        item.sellIn -= dayDecrease
    }

    private fun isExpired(item: Item): Boolean {
        return item.sellIn <= 0
    }

    private fun hadQuality(item: Item): Boolean {
        return item.quality > minQuality
    }

    private fun decreaseQuality(item: Item) {
        item.quality -= this.qualityDecrease
    }

}
```

Lo mismo para el resto de items. No importa mucho si de momento dejamos clases
privadas duplicadas. La clase `GildedRose` quedar√≠a as√≠:

`GildedRose.kt`

```kotlin
class GildedRose(var items: List<Item>) {
    fun updateQuality() {
        items.forEach { item ->
            val updater = when (item.name) {
                "Aged Brie" -> AgedBrieUpdater()
                "Backstage passes to a TAFKAL80ETC concert" -> BackstagePassUpdater()
                "Sulfuras, Hand of Ragnaros" -> SulfurasUpdater()
                else -> DefaultItemUpdater()
            }
            updater.updateQuality(item)
            updater.decreaseSellIn(item)
        }
    }
}
```

## üì• Falta de Encapsulaci√≥n

La soluci√≥n propuesta puede enfrentar varios problemas de falta de
encapsulaci√≥n. La creaci√≥n directa de instancias de `ItemUpdater` dentro del
m√©todo `updateQuality` de la clase `GildedRose` podr√≠a violar el principio de
encapsulaci√≥n, ya que idealmente, la creaci√≥n y gesti√≥n de estos objetos deber√≠a
estar encapsulada en una f√°brica o en un proveedor de servicios. Adem√°s, las
clases `ItemUpdater` espec√≠ficas est√°n expuestas y pueden ser accedidas desde
fuera de la clase `GildedRose`, lo que puede dar lugar a un acoplamiento no
deseado.

`ItemUpdaterFactory.kt`

```kotlin
class ItemUpdaterFactory {
    fun getUpdater(item: Item): ItemUpdater {
        return when(item.name) {
            "Aged Brie" -> AgedBrieUpdater()
            "Backstage passes to a TAFKAL80ETC concert" -> BackstagePassUpdater()
            "Sulfuras, Hand of Ragnaros" -> SulfurasUpdater()
            else -> DefaultItemUpdater()
        }
    }
}
```

`GildedRose.kt`

```kotlin
class GildedRose(var items: List<Item>) {
    private val itemUpdaterFactory = ItemUpdaterFactory()

    fun updateQuality() {
        items.forEach { item ->
            val updater = itemUpdaterFactory.getUpdater(item)
            updater.updateQuality(item)
            updater.decreaseSellIn(item)
        }
    }
}
```

Tambi√©n, las clases `ItemUpdater` modifican directamente las propiedades de
`Item`, violando la encapsulaci√≥n ya que cualquier modificaci√≥n a los estados de
un objeto deber√≠a ser manejada a trav√©s de m√©todos en la clase del objeto. La
falta de abstracci√≥n para diferentes tipos de items y la modificaci√≥n directa de
las propiedades de `Item` sin m√©todos setter que permitan controlar o validar
las modificaciones, podr√≠an llevar a estados inv√°lidos o inconsistentes. Cada
tipo espec√≠fico de item tendr√≠a su propia subclase de Item, y cada subclase
implementar√≠a los m√©todos de actualizaci√≥n de calidad y decrecimiento de sellIn
directamente. La falta de extensibilidad y flexibilidad se evidencia si se
necesitan agregar m√°s tipos de items en el futuro, ya que se tendr√≠a que
modificar la expresi√≥n `when` en `GildedRose`, violando el principio de
abierto/cerrado. Hare una implementaci√≥n basada en el c√≥digo de los
ItemUpdaters:

`Item.kt`

```kotlin
abstract class Item(protected val name: String, protected var sellIn: Int, protected var quality: Int) {
    protected val minQuality = 0
    protected val maxQuality = 50
    protected val qualityIncrease = 1
    protected val qualityDecrease = 1
    protected val dayDecrease = 1
    abstract fun updateQuality()
    abstract fun decreaseSellIn()
    abstract fun currentQuality(): Int
}
```

`DefaultItem.kt`

```kotlin
class DefaultItem(name: String, sellIn: Int, quality: Int) : Item(name, sellIn, quality) {
    override fun updateQuality() {
        if (hadQuality()) {
            decreaseQuality()
        }
        if (isExpired() && hadQuality()) {
            decreaseQuality()
        }
    }
    override fun decreaseSellIn() {
        sellIn -= dayDecrease
    }

    override fun currentQuality(): Int {
        return quality
    }

    private fun isExpired(): Boolean {
        return sellIn <= 0
    }

    private fun hadQuality(): Boolean {
        return quality > minQuality
    }

    private fun decreaseQuality() {
        quality -= this.qualityDecrease
    }
}
```

Ya no hace falta la dependencia de `Item` como en el caso de `ItemUpdater` ya
que la clase `GildedRose` no necesita conocer los detalles de implementaci√≥n de
`Item`. La clase `GildedRose` solo necesita conocer la interfaz de `Item` para
poder actualizar los items. La clase `GildedRose` quedar√≠a as√≠:

`GildedRose.kt`

```kotlin
class GildedRose(var items: List<Item>) {
    fun updateQuality() {
        items.forEach { item ->
            item.updateQuality()
            item.decreaseSellIn()
        }
    }
}
```

Una soluci√≥n m√°s encapsulada y extensible podr√≠a ser implementar una f√°brica o
un registro de actualizadores de items que pueda ser extendido sin modificar el
c√≥digo existente. El problema es que implementar esta soluci√≥n ha costado mucho
mas que los otros cambios. Por suerte ya ten√≠amos la implementaci√≥n en el
updater.

## üçÉ Problemas de Extensibilidad y Mantenibilidad

Para concluir este gran art√≠culo, voy a comentar los problemas de
extensibilidad. La soluci√≥n actual presenta desaf√≠os de extensibilidad y
mantenibilidad, como la dificultad en la adici√≥n de nuevos tipos de items y la
modificaci√≥n de la l√≥gica de actualizaci√≥n, lo que podr√≠a resultar en c√≥digo
duplicado. Tambi√©n hay una dispersi√≥n en la validaci√≥n de la calidad del item,
lo que puede conducir a cambios en m√∫ltiples lugares si las reglas de validaci√≥n
evolucionan. Aunque se han creado subclases para diferentes tipos de items, la
falta de polimorfismo y la violaci√≥n de la separaci√≥n de responsabilidades,
donde las subclases de `Item` manejan tanto la representaci√≥n de datos como la
l√≥gica de actualizaci√≥n, pueden afectar negativamente la mantenibilidad. Adem√°s,
la soluci√≥n muestra una "obsesi√≥n primitiva", al depender en gran medida de
tipos de datos primitivos y estructuras de control en lugar de encapsular la
l√≥gica en clases y m√©todos bien definidos, lo que podr√≠a complicar futuras
extensiones y refactorizaciones del sistema.

Os imagin√°is si lo primero que hago es crear una clase `Item` con su l√≥gica? Es
muy probable que sin un poco de limpieza y refactorizaci√≥n no hubiera sido
posible.

Siempre se puede ir mejorando pero hay que saber cuando parar, es probable que
la soluci√≥n cuando la visiten este cambiada o ni siquiera se haya acabado la
Kata üòπ. Espero que os haya gustado este art√≠culo y que os haya servido para
aprender algo nuevo.

## üìö Referencias

- [Repositorio](https://github.com/Wolfremium13/kata-guilded-rose)
- [Pedro Santos](https://www.youtube.com/watch?v=-M0KZHNBgG8)
- [Emily Bache](https://youtu.be/K7xSsNpeM8I?si=_mvk53iliLsut_ut)
- [Carlos Ble](https://www.youtube.com/@carlosble/videos)
- [Martin Fowler](https://martinfowler.com/articles/refactoring-2nd-ed.html)
