---
title: "üß® La magia de la prueba y error"
date: "2023-03-05"
preview: "/assets/blog/the-magic-of-testing-and-error/cat-magic.webp"
tags:
  - "üë®‚Äçüíª Aprendizaje"
---

En una formaci√≥n de [Lean Mind](https://leanmind.es/es/) se empez√≥ a hablar del
problema de encontrar errores en soluciones tecnol√≥gicas grandes, como
desarrolladores de software debemos intentar evitar al m√°ximo pr√°cticas del tipo
‚Äúprueba y error‚Äù sin un criterio o rigor cient√≠fico donde se anotan las pruebas
y resultados. Este es un tema interesante ya que por mucho test que tengamos se
nos cuelan errores que se escapan a nuestro contexto del desarrollo como pueden
ser las caracter√≠sticas no funcionales de un programa, como por ejemplo la
conectividad, ¬øqu√© pasa si se cae la red repetidas veces en nuestro proceso de
subida? ¬øSer√° capaz nuestro software de ser resiliente al problema? Los tests
[no funcionales](https://testerhouse.com/teoria-testing/pruebas-funcionales/#nbspPruebas_no_Funcionalesnbsp)
tambi√©n son igual de importantes aunque no siempre se le den la importancia que
se merecen a√∫n si son dif√≠ciles de testear. Veamos como ser√≠a ignorarlo
completamente:

<MdxImage
  src="/assets/blog/the-magic-of-testing-and-error/cat-explode-tnt-preparation.gif"
  alt="cat-explosion"
></MdxImage>

Investigar y plasmar un problema en una imagen que pueda ser actualizada en base
a los nuevos descubrimientos es fundamental, herramientas como
[Excalidraw](https://excalidraw.com/) por ejemplo me permiten plasmar el flujo
de un problema de tal manera que sea comprensible por m√≠ y mis compa√±eros, a
parte tienes un hist√≥rico de prueba y error. Una ventaja adicional de usar este
m√©todo es plasmar el diagrama en el ticket que est√©s trabajando haciendo f√°cil
de asimilar por tu responsable la magnitud o complejidad del problema, es
importante para todos pero a lo mejor no es tan urgente ya que lleva varios
meses all√≠ y nadie dijo nada. Valorar la importancia de un problema es tambi√©n
importante para no perder el tiempo.

Un aspecto importante es concretar como equipo la resoluci√≥n de problemas, por
ejemplo si en el mob programming se crea mucho ruido con comentarios que no
tienen que ver etc. y es improbable que puedas aprender o tener el suficiente
foco como para intentar encajar las piezas del problema en tu cabeza. Tener
buena memoria puede ayudarte pero no suele ser suficiente. Tomarse tu tiempo
solo es importante para ir iterando en una soluci√≥n con el equipo, juntos pero
buscando por separado aportando diferentes perspectivas si as√≠ el equipo lo
decide, lo ideal es llegar con un plan trazado poco a poco o una hip√≥tesis y
plantear o implementarla con el equipo.

> El m√©todo Feynman es un modelo mental que se utiliza como t√©cnica de
> comprensi√≥n para ayudarnos a aprender algo, por muy complicado de entender que
> sea.

El software tiende a ser determinista, lo cual es contradictorio de la idea de
‚Äúesta librer√≠a hace magia‚Äù o ‚Äúesto de vez en cuando devuelve otra cosa‚Äù, lo
ideal en estos casos es reducir la incertidumbre en nuestro trabajo hasta donde
se pueda. Problemas como la concurrencia, son complejos a nivel de algoritmos,
trazar un plan de ingenier√≠a de c√≥mo vas a irte acercando de una manera ordenada
a esa soluci√≥n final es clave para un buen dise√±o o hip√≥tesis. Si en este caso
pensamos en magia vamos a ir dando palos de ciego hasta que demos con la
soluci√≥n final que podr√≠a ser 3 entre 100000000, casi que la loter√≠a es m√°s
rentable.

Finalmente un factor muy importante es la experiencia, todo el tiempo que le
dediques a estudiar un problema no es tiempo perdido, aunque si tienes una
entrega el viernes es importante ser pragm√°tico, en mi experiencia si la pieza
de c√≥digo no es muy determinista o genera muchas soluciones de multitud de
combinaciones, como puede ser en data engineering donde no hay control de los
datos, lo mejor es definir la soluci√≥n que consideramos correcta y forzar al
c√≥digo a solo generar esa o fallar. Esto me ha ayudado a reducir la carga
cognitiva del c√≥digo y evitar la gesti√≥n de multitud de soluciones de un c√≥digo.
Los test unitarios o de integraci√≥n no captar√°n el error hasta que el input del
programa cambie, tener un buen sistema de observabilidad es muy importante para
buscar y encontrar este tipo de errores.

## Conclusi√≥n

Es muy importante entender que el software tiene errores, es muy dif√≠cil generar
una soluci√≥n sin ellos por lo cual es importante tener un cierto rigor a la hora
de encontrar estos errores ya que si tus clientes los encuentran antes les
saldr√° muy caro a tu producto y a ti.
